#include <stdio.h>#define max(a,b) (a > b ? a : b)int mochila[100][100] = {0};int algoritmo(int indice, int cap, int peso[],int valor[]){	int tomado,notomado;    tomado = notomado = 0;	    if (mochila[indice][cap] != 0)        return mochila[indice][cap];    	if (indice==0){ // Lleno la primera fila, o sea, la relacion entre el primero objeto y la capacidad        if (peso[0]<=cap){            mochila[indice][cap] = valor[0];            return valor[0];        }        else{			mochila[indice][cap] = 0;            return 0;        }    }    if (peso[indice]<=cap)        tomado = valor[indice] + algoritmo(indice-1, cap-peso[indice], peso, valor);    notomado = algoritmo(indice-1, cap, peso, valor);    mochila[indice][cap] = max (tomado, notomado);	    return mochila[indice][cap];}int main(){    int nItems = 5;    int capacidad = 100;    int peso[4] = {40,30,120,5};    int valor[4] = {5,13,654,65};    printf("Max valor = %d \n",algoritmo(nItems-1, capacidad, peso, valor));    return 0;}/*Sea m[i,j] un arreglo que almacena el valor máximo de los objetos que podemos transportar si el límite de peso es j, con 0=j = C, y si solamente incluimos los objetosnumerados desde 1 hasta el i, con 1=i =n. Por tanto, la solución se puede encontrar en m[n,C]. La tabla se llena con la regla:		-> Si j=0 entonces m[i,0] = 0, quiere decir que ningún objeto se puede acomodar en una mochila de capacidad cero.		-> Si j>0 entonces m[i,j] = max (m[i-1, j], m[i-1, j-pi] + bi), quiere decir que se evalúa la opción de no añadir el objeto i a la		carga contra la opción de incluirlo, lo cual tiene como efecto incrementar el valor de la carga en bi, y reducir la capacidad		disponible en pi.*/